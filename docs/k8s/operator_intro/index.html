<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Оператор #  Доклад
 сущность, управляющая другими сущностями в кластере содержит шаблоны поведения основные задачи:  облегчение жизни операторов k8s уменьшение количества микроменеджмента (автоматизация типовых задач по обслуживанию кластера)    Оператор обслуживает весь жизненный цикл (например масштабирование, шардирование и т.д.; в отличии от Helm, который только ставит пакеты)
При построении оператора исходить из того, что он будет управлять необходимой сущностью как одним ресурсом (в качестве примера, оператор для кластера CH, который воспринимает его как одну сущность)"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Operator intro"><meta property="og:description" content="Оператор #  Доклад
 сущность, управляющая другими сущностями в кластере содержит шаблоны поведения основные задачи:  облегчение жизни операторов k8s уменьшение количества микроменеджмента (автоматизация типовых задач по обслуживанию кластера)    Оператор обслуживает весь жизненный цикл (например масштабирование, шардирование и т.д.; в отличии от Helm, который только ставит пакеты)
При построении оператора исходить из того, что он будет управлять необходимой сущностью как одним ресурсом (в качестве примера, оператор для кластера CH, который воспринимает его как одну сущность)"><meta property="og:type" content="article"><meta property="og:url" content="https://morggoth.github.io/docs/k8s/operator_intro/"><meta property="article:published_time" content="2020-12-23T23:27:15+03:00"><meta property="article:modified_time" content="2020-12-23T23:27:15+03:00"><title>Operator intro | Morggoth's wiki</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.6cd8553a6854f4812343f0f0c8baca31271e686434f381fbe3c7226f66639176.css integrity="sha256-bNhVOmhU9IEjQ/DwyLrKMSceaGQ084H748cib2ZjkXY="><script defer src=/en.search.min.868d001c2b13c2c9b7ad8df750387f743437ab6a93171a26f60958a63969a0c6.js integrity="sha256-ho0AHCsTwsm3rY33UDh/dDQ3q2qTFxom9glYpjlpoMY="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>Morggoth's wiki</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/docs/cloud/ class=collapsed>Cloud</a></li><li><a href=/docs/k8s/ class=collapsed>Kubernetes</a><ul><li><a href=/docs/k8s/common_notes/>Common k8s notes</a></li><li><a href=/docs/k8s/operator_intro/ class=active>Operator intro</a></li><li><a href=/docs/k8s/foundation_of_kubernetes/>Foundation of Kubernetes</a></li></ul></li><li><a href=/docs/mooc/ class=collapsed>Courses notes</a></li><li><a href=/docs/misc/prometheus/>Prometheus</a></li><li><a href=/docs/misc/docker/>Основы Docker</a></li><li><a href=/docs/misc/cheatsheets/>Cheatsheets</a></li><li><a href=/docs/misc/rpi/>Raspberry Pi</a></li><li><a href=/docs/misc/kafka/>Kafka basics</a></li><li><a href=/docs/misc/old_hardware/>Old hardware</a></li><li><a href=/docs/languages/ class=collapsed>Languages</a></li><li><a href=/docs/misc/chromeos/>ChromeOS</a></li><li><a href=/docs/misc/macos/>macOS</a></li><li><a href=/docs/misc/mikrotik/>Mikrotik</a></li><li><a href=/docs/misc/tips_and_tricks/>Tips & Tricks</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Operator intro</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#оператор>Оператор</a><ul><li><a href=#persistent-storage>Persistent storage</a></li><li><a href=#взаимодействие-оператора-с-k8s>Взаимодействие оператора с k8s</a></li><li><a href=#цикл-обработки-событий-оператором>Цикл обработки событий оператором</a></li><li><a href=#разделение-ответственности-между-k8s-и-оператором>Разделение ответственности между k8s и оператором</a></li></ul></li><li><a href=#jobs--cronjobs>Jobs & CronJobs</a></li></ul></nav></aside></header><article class=markdown><h2 id=оператор>Оператор
<a class=anchor href=#%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80>#</a></h2><p><a href="https://www.youtube.com/watch?v=z2aARjKDg4w&feature=emb_title">Доклад</a></p><ul><li>сущность, управляющая другими сущностями в кластере</li><li>содержит шаблоны поведения</li><li>основные задачи:<ul><li>облегчение жизни операторов k8s</li><li>уменьшение количества микроменеджмента (автоматизация типовых задач по обслуживанию кластера)</li></ul></li></ul><p>Оператор обслуживает весь жизненный цикл (например масштабирование, шардирование и т.д.; в отличии от Helm, который только ставит пакеты)</p><p>При построении оператора исходить из того, что он будет управлять необходимой сущностью как одним ресурсом (в качестве примера, оператор для кластера CH, который воспринимает его как одну сущность)</p><p>Манифест для однонодной инсталяции CH:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#e6db74>&#34;clickhouse.altinity.com/v1&#34;</span>    <span style=color:#75715e># NB - apiVersion ссылается на другой URL</span>
<span style=color:#f92672>kind</span>: <span style=color:#e6db74>&#34;ClickHouseInstallation&#34;</span>              <span style=color:#75715e># NB - кастомная сущность</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;demo-01&#34;</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>configuration</span>:
    <span style=color:#f92672>clusters</span>:
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>&#34;demo</span>
</code></pre></div><h3 id=persistent-storage>Persistent storage
<a class=anchor href=#persistent-storage>#</a></h3><p>Local storages:</p><ul><li>emptyDir<ul><li>доступ к каталогу на хост-машине через демон контейнеризации</li><li>работает со скоростью доступа к локальному диску</li><li>данные приколочены к ноде, при перемещении пода, данные теряются</li></ul></li><li>hostPath<ul><li>использование конкретного каталога на хостовой машине</li><li>при перемещении на другую ноду данные не переносятся</li></ul></li><li>local<ul><li>все то же самое, но локальный каталог управляется самим k8s</li></ul></li></ul><h3 id=взаимодействие-оператора-с-k8s>Взаимодействие оператора с k8s
<a class=anchor href=#%d0%b2%d0%b7%d0%b0%d0%b8%d0%bc%d0%be%d0%b4%d0%b5%d0%b9%d1%81%d1%82%d0%b2%d0%b8%d0%b5-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d0%b0-%d1%81-k8s>#</a></h3><p>kubectl apply -> новые объекты -> API -> Etcd</p><p><em>Controller</em> - сущность, которая реализует изменения в наборе объектов, которые были записаны в Etcd.</p><p>Custom Resource Definition - описание &ldquo;структуры данных&rdquo;</p><p>Operator (Custom Resource Controller) - контроллер, который может создать кастомный ресурс. До его появления в кластере, даже если кастомный ресурс будет добавлен в Etcd, ничего не произойдет, потому что дефолтный контроллер не знает что с ним делать.</p><p>Оператор может исполняться снаружи кластера.</p><h3 id=цикл-обработки-событий-оператором>Цикл обработки событий оператором
<a class=anchor href=#%d1%86%d0%b8%d0%ba%d0%bb-%d0%be%d0%b1%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%ba%d0%b8-%d1%81%d0%be%d0%b1%d1%8b%d1%82%d0%b8%d0%b9-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d0%be%d0%bc>#</a></h3><ul><li>с помощью K8s API <em>подписывается</em> на те или иные события</li><li>при наступлении события, <em>реагирует</em> на него тем или иным образом<ul><li>составление плана действий</li><li>исполнение поставленного плана</li></ul></li></ul><h3 id=разделение-ответственности-между-k8s-и-оператором>Разделение ответственности между k8s и оператором
<a class=anchor href=#%d1%80%d0%b0%d0%b7%d0%b4%d0%b5%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%be%d1%82%d0%b2%d0%b5%d1%82%d1%81%d1%82%d0%b2%d0%b5%d0%bd%d0%bd%d0%be%d1%81%d1%82%d0%b8-%d0%bc%d0%b5%d0%b6%d0%b4%d1%83-k8s-%d0%b8-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%82%d0%be%d1%80%d0%be%d0%bc>#</a></h3><p>k8s - отвечает за системные ресурсы, базовый набор объектов
Оператор - действует только в своей предметной области</p><p>Если на момент наступления <em>события</em>, оператор не мог его обработать, k8s продублирует отправку этого события (то есть, видимо, должна быть обратная связь). Т.о., задача оператора, в том числе, <em>обеспечение идемпотентности</em>.</p><h2 id=jobs--cronjobs>Jobs & CronJobs
<a class=anchor href=#jobs--cronjobs>#</a></h2><p>Вспомним, как в Kubernetes реализована концепция остановки подов. Когда приходит время остановить под, то есть все контейнеры в поде, контейнерам посылается sigterm-сигнал и Kubernetes ждёт определённое время, чтобы приложение внутри контейнера отреагировало на этот сигнал.</p><p>В нашем случае приложение — это простой bash-скрипт с бесконечным циклом, реагировать на сигнал некому. Kubernetes ждёт время, которое задано в параметре graceful shutdown. По дефолту — 30 секунд. То есть если за 30 секунд приложение на sigterm не среагировало, дальше посылается sigkill и процесс с pid 1 внутри контейнера убивается, контейнер останавливается.
Поле restartPolicy</p><p>При проверке backoffLimit поды у нас перезагружались. При этом в манифесте указан параметр restartPolicy: Never. Но когда мы смотрели, как работает опция backoffLimit, поды перезагружались. Здесь нет противоречия: если вы посмотрите на весь yaml-файл, то заметите, что этот параметр относится не к Job, а к спецификации контейнера, который запускается внутри пода.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>batch/v1</span>
<span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Job</span>
<span style=color:#f92672>metadata</span>:
  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
<span style=color:#f92672>spec</span>:
  <span style=color:#f92672>backoffLimit</span>: <span style=color:#ae81ff>2</span>
  <span style=color:#f92672>activeDeadlineSeconds</span>: <span style=color:#ae81ff>60</span>
  <span style=color:#f92672>template</span>:
    <span style=color:#f92672>spec</span>:
      <span style=color:#f92672>containers</span>:
      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>hello</span>
        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>busybox</span>
        <span style=color:#f92672>args</span>:
        - <span style=color:#ae81ff>/bin/sh</span>
        - -<span style=color:#ae81ff>c</span>
        - <span style=color:#ae81ff>date; echo Hello from the Kubernetes cluster</span>
      <span style=color:#f92672>restartPolicy</span>: <span style=color:#ae81ff>Never</span>
</code></pre></div><p>Этот параметр говорит kubelet, что делать с контейнером после того, как он был завершён с ошибкой. По умолчанию стоит политика Always, то есть если у нас контейнер в поде завершился, kubelet этот контейнер перезапускает. Причем, все остальные контейнеры в поде продолжают работать, а перезапускается только упавший контейнер.</p><p>Это политика по умолчанию, и если её применить в Job, то Job-контроллер не сможет получить информацию о том, что под был завершён с ошибкой. С его точки зрения под будет очень долго выполняться, а то, что kubelet перезапускает упавший контейнер, Job-контроллер не увидит.</p><p>Если вы укажете только backoffLimit, но забудете указать restartPolicy, то Job будет выполняться бесконечно.
Поэтому в Job надо всегда указывать:
backoffLimit (количество попыток),
activeDeadlineSeconds (общее время),
restartPolicy: Never (сказать kubelet, чтобы он никогда не перезапускал контейнер в поде; если контейнер в поде упал, то и сам под считается упавшим, то есть завершённым. Пусть Job-контроллер разбирается, что произошло).</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#оператор>Оператор</a><ul><li><a href=#persistent-storage>Persistent storage</a></li><li><a href=#взаимодействие-оператора-с-k8s>Взаимодействие оператора с k8s</a></li><li><a href=#цикл-обработки-событий-оператором>Цикл обработки событий оператором</a></li><li><a href=#разделение-ответственности-между-k8s-и-оператором>Разделение ответственности между k8s и оператором</a></li></ul></li><li><a href=#jobs--cronjobs>Jobs & CronJobs</a></li></ul></nav></aside></main></body></html>