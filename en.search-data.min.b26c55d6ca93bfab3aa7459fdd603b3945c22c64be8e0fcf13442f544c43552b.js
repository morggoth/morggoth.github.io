'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/misc/math/sets/','title':"Теория множеств",'content':"Теория множеств Основные понятия Множество - совокупность элементов, объединенных по какому-либо признаку.\nМножества:\n конечные бесконечные  Обозначения:\n  $$ x \\in X - x \\text{ является элементом множества } Х \\\\ x \\forall - \\text{ для всех } x \\\\ x \\exists - \\text{ существует } x \\\\ \\alpha \\implies \\beta - \\text{ следовательно(импликация) } \\\\ \\alpha \\iff \\beta - \\text{ эквивалентно } \\\\ U - \\text{ универсум } \\\\ $$ Универсум (универсальное множество) - разумное множество элементов, за пределы которого не выходят при рассмотрении больших множеств.\nПодмножества Обозначается: $$ A \\subset B - \\text{ (теоретико-множественное) включение } $$ Определение: $$ x \\in A \\implies x \\in B $$ Т.е. A есть часть B.\n $$ A = B \\text{ if } A \\subset B \\text{ and } B \\subset A $$ Т.e. множества A и B состоят из одних и тех же элементов.\nОперации над множествами  Объединение(\u0026ldquo;ИЛИ\u0026rdquo;) $$ A \\cup B $$  Пересечение(\u0026ldquo;И\u0026rdquo;) $$ A \\cap B $$  Дополнение (\u0026ldquo;НЕ\u0026rdquo;; множество всех элементов U, не входящих в А) $$ \\overline{A} $$   Пустое множество $$ \\varnothing $$ Не имеет ни одного элемента. Таким образом, пересечение непересекающихся множеств даёт:\n$$ A \\cap B = \\varnothing $$ Основные свойства: $$ A \\cup \\varnothing = A \\\\ A \\cap \\varnothing = \\varnothing \\\\ A \\cap \\overline{A} = \\varnothing\\\\ \\overline{\\varnothing} = U \\\\ \\varnothing = \\overline{U} \\\\ $$ Производные свойства множеств $$ A \\cup B = B \\cup A \\\\ A \\cup A = A \\\\ A \\cap B = B \\cap A \\\\ A \\cap A = A \\\\ A \\cup \\overline{A} = U \\\\ \\overline{\\overline{A}} = A \\\\ A \\cup ( B \\cup C ) = ( A \\cup B ) \\cup C \\\\ A \\cap ( B \\cap C ) = ( A \\cap B ) \\cap C \\\\ A \\cap ( B \\cup C ) = ( A \\cap B ) \\cup ( A \\cap C ) \\\\ A \\cup ( B \\cap C ) = ( A \\cup B ) \\cap ( A \\cup C ) \\\\ $$ Объединение и пересечение произвольного числа множеств $$ A_1, A_2, ..., A_m $$ обозначается:\n$$ \\bigcup_{i=m}^m A_i \\Big( \\bigcap_{i=m}^m A_i\\Big) $$ Формулы Де Моргана $$ \\overline{A \\cup B} = \\overline{A} \\cap \\overline{B} \\\\ \\overline{A \\cap B} = \\overline{A} \\cup \\overline{B} $$ Теория бесконечных множеств Пусть $$ f : X \\to Y $$ т.е. f - отображение (\u0026ldquo;функция\u0026rdquo;), у которой множеством задания является Х, на множество значений лежит в Y. Тогда каждому:\n$$ x \\in X $$ сопоставляется элемент $$ y = f(x) \\in Y $$ Отображение такого вида называется взаимно однозначным соответствием, если для каждого $$ y \\in Y $$ существует единственный элемент $$ x \\in X $$ такой, что $$ f(x) = y $$ Если для множеств X и Y существует взаимно однозначное соответствие, то эти множества называются эквивалентными или равномощными. Обозначается $$ X \\sim Y $$ Свойства эквивалентности: $$ X \\sim X \\\\ X \\sim Y \\implies Y \\sim X \\\\ X \\sim Y, Y \\sim Z \\implies X \\sim Z $$ Мощность множества А - класс всех эквивалентных ему множеств. Соответственно, мощности множеств равны тогда и только тогда, когда они эквивалентны.\nИзначально мощность множества выражалась через количество его элементов.\nМножество, эквивалентное натуральному ряду называется счетным, не эквивалентное - несчетным.\nМощности четных(и нечетных), натуральных, целых и рациональных чисел равны. Кроме того, они равны и мощностям плоскости и трёхмерного пространства.\nМощность числовой прямой также носит название континуум.\nТеория конечных множеств Является частью дискретной математики.\nКомбинаторика - раздел математики, посвященный решению задач выбора и расположения элементов некоторого, обычно конечного множества в соответствии с заданными правилами.\nЕсли мы имеем дело с непустым конечным множеством M, состоящим из m элементов, это обозначается как:\n$$ |M| = m $$ Отличие от обозначения модуля числа определяется только по контексту.\nРазмещение из m элементов по n - упорядоченный набор, составленный из n различных элементов множества M. $$ 1 \\le n \\le m $$ Обозначается: $$ A^n_m = \\frac{m!}{(m-n)!} $$ Перестановкой называют размещение из m элементов по m.\n$$ P_m = m! $$ Сочетанием из m элементов по n называется набор, состоящий из n различных элементов множества M.\n$$ C^n_m = \\frac{A^n_m}{P_m} = \\frac{m!}{(m-n)n!} $$ Сочетание может быть использовано, например, для определения коэффициентов многочлена $$ (1 + x)^m $$ при некотором фиксированном m:\n $$ (1+x)^m = C_m^0 + C_m^1x + C_m^2x^2+...+C_m^mx^m = \\sum_{n=0}^m C_m^nx^n $$ Эта формула называется биномом Ньютона, а сочетания в ней - биноминальными коэффициентами. Их сумма: $$ \\sum_{n=0}^m C^n_m = 2^m $$ "});index.add({'id':1,'href':'/docs/misc/math/numbers/','title':"Числа",'content':"Числа Появление чисел Натуральное число в десятичной записи имеет вид:   $$ n = \\sum_{m=0}^{k-1} a_m 10^m \\\\ 0 \\le a-m \\le 9 \\text{, } m = 0, 1,...,k-1 $$ Расширяя эту формулу можно записать, что любое натуральное число $$ n \\in \\N $$ может быть представлено в виде: $$ n = \\sum_{m=0}^{k-1} b_mp^m \\\\ 0 \\le b_m \\le p-1, m = 0, 1,..., k-1 $$ Это число записывается в p-ричной системе счисления, имеющей p цифр.\n9376 - единственное четырехзначное число, у которого при возведении в квадрат сохраняются последние 4 цифры: 9376^2 = 87909376  Целые числа(расширение натуральных чисел отрицательными и нулём):\n$$ x + q = p \\\\ p, q \\in \\N $$ Рациональные числа(расширение целых чисел дробями):\n$$ qx = p \\\\ p,q \\in \\Z, q \\ne 0 $$ Вещественные числа(расширяют рациональные иррациональными; возникли из необходимости измерения непрерывных величин)\nТеорема: корень квадратный из 2 - иррациональное число Доказательство от противного. Предположим, что это рациональное число, тогда: $$ \\sqrt 2 = \\frac{p}{q} \\\\ p,q \\in \\N $$ p и q - взаимно простые числа(то есть не имеют общих делителей, кроме 1) =\u0026gt; по крайней мере одно из них - нечетное. Возводя обе части равенства в квадрат, получаем: $$ p^2 = 2q^2 $$ Откуда следует, что p - четное число, таким образом, $$ p = 2m \\\\ m \\in \\N $$ Подставляя это выражение вместо p в предыдущее равенство, получаем: $$ 4m^2 = 2q^2 \\implies 2m^2 = q^2 $$ откуда следует, что и q - четное, что является противоречием.\nТеория чисел Теория чисел - раздел математики, изучающий целые числа.\nТеория простых чисел - натуральное число p \u0026gt; 1 называется простым, если оно делится только на единицу и на само себя. Натуральное число q \u0026gt; 1, не являющееся простым, называется составным.\nТеорема Евклида: Множество простых чисел бесконечно.\nДоказательство. Предположим обратное. Тогда: $$ n_1 $$ p = n_1n_2...n_m + 1 $$ Так как p - больше наибольшего простого числа, оно составное. Но в этом случае, оно должно делиться на одно из простых чисел, однако из вида этого числа следует, что при делении его на любое простое число получится остаток 1, что и является искомым противоречием.\nЕвклидом же был введено понятие чисел-близнецов. Это такие простые числа: $$ p, q, \\text{ } p  q \\\\ p - q = 2 $$ Он же поставил вопрос, является ли множество чисел близнецов бесконечным? Этот вопрос до сих пор не имеет ответа.\nТреугольник со сторонами 3,4,5 - называется египетский.  Теорема Ферма: Не существует натуральных чисел x, y, z, удовлетворяющих уравнению $$ x^n + y^n = z^n \\\\ n \\ge 3 $$ "});index.add({'id':2,'href':'/docs/misc/math/complex_numbers/','title':"Комплексные числа",'content':"Комплексные числа Появились в XVIв. в процессе исследования алгебраических уравнений(квадратных, кубических и т.д.). Как известно из школьного курса алгебры, некоторые такие уравнения \u0026ldquo;не имеют корней\u0026rdquo;. Но это верно только на множестве вещественных чисел. Для решения этой проблемы множество вещественных чисел было расширено так, чтобы подобные корни появились. Другое название комплексных чисел - мнимые.\nПо определению комплексно число - это упорядоченная пара вещественных чисел, обозначаемая (a, b). Эти числа можно интерпретировать как координаты точки(a - абсцисса, b - ордината).\nАбсцисса - координата точки по оси X\nОрдината - \u0026ndash;\\\u0026ndash; Y\nАппликата - \u0026ndash;\\\u0026ndash; Z  Два комплексных числа (a, b) и (c, d) считаются равными тогда и только тогда, когда:   $$ a = c \\\\ b = d $$ Сложение комплексных чисел: $$ (a, b) + (c, d) = (a+c, b+d) $$ Умножение: $$ (a, b)(c, d) = (ac - bd, ad + bc) $$ Таким образом, произведение не зависит от порядка сомножителей.\nВычитание - нахождение неизвестного слагаемого\nДеление - нахождение неизвестного сомножителя  $$ (a, b) - (c, d) = (a-c, b-d) \\\\ \\\\ \\dfrac{(a,b)}{(c,d)} = \\Big( \\dfrac{ac+bd}{c^2+d^2}, \\dfrac{bc-ad}{c^2+d^2} \\Big) \\text{ ,где}\\\\ (c,d) \\ne (0,0) $$ Рассмотрим точки, лежащие на оси абсцисс, например (a, 0). Для таких комплексных чисел операции сложения и умножения дают следующие результаты: $$ (a,0) + (b,0) = (a+b,0) \\\\ (a,0)(b,0) = (ab, 0) $$ из которых видно, что алгебра комплексных чисел, лежащих на лси абсцисс совпадает с алгеброй вещественных чисел, таким образом: $$ (a,0) = a $$ Все вещественные числа (и только они) лежат на оси абсцисс, которая так же является числовой прямой. А все точки с ненулевой ординатой являются невещественными числами.\nДокажем, что в множестве комплексных чисел существует корень уравнения: $$ x^2 + 1 = 0 $$ то есть, существует число, квадрат которого равен -1. Для этого возведем в квадрат число (0, 1): $$ (0,1)(0,1) = (-1,0) = -1 $$ Комплексное число (0,1), называемое мнимой единицей, Л. Эйлер предложил обозначать буквой i: $$ i^2 = -1 $$ Таким образом, точкам оси ординат отвечают комплексные числа вида bi, где b - произвольное вещественное число.\nОбычно комплексные числа записывают в виде: $$ a + bi $$ Такая запись использует декартовы координаты точки. Кроме того, существует тригонометрическая форма записи комплексного числа. Положение точки на плоскости может быть определено с помощью расстояния от этой точки до начала координат и угла между положительным направлением оси абсцисс и лучом, выходящим из начала координат и проходящим через эту точку.\nДля комплексного числа a+bi упомянутые величины обозначаются через: $$ r \\text{ - расстояние} \\\\ \\varphi \\text{ - угол} $$ Таким образом, при любом расположении точки a + bi на координатной плоскости справедливы соотношения: $$ x = r \\cos \\varphi, \\\\ y = r \\sin \\varphi $$ Отсюда, а так же из теоремы Пифагора следует: $$ r = \\sqrt{a^2 + b^2} $$ Число r называется модулем комплексного числа a + bi, а угол - аргументом. При r = 0 модуль не определен. Единственное число с нулевым модулем - (0,0)\nК комплексным числам не применимы неравенства типа \u0026ldquo;больше\u0026rdquo; или \u0026ldquo;меньше\u0026rdquo;, поэтому сравнивать их можно только по модулю.\nОсновная теорема алгебры Пусть $$ P(z) = a_0 + a_1 z + a_2 z^2 + ... + a_n z^n - $$ многочлен(полином) с комплексными коэффициентами $$ a_0, a_1, a_2,...,a_n $$ заданный в комплексной плоскости, т.е. множестве чисел z = a + bi. Если $$ a_n \\ne 0 $$ то говорят, что многочлен P имеет степень n.\nОсновная теорема алгебры: Если степень многочлена n \u0026gt;= 1, то уравнение $$ P(z) = 0 $$ имеет, по крайней мере один комплексный корень.\nЭто утверждение также называется Теоремой Гауса.\nОсновным следствием этой теоремы является то, что любой многочлен степени n \u0026gt;= 1 может иметь не более n корней (при этом некоторые из них могут совпадать).\nСтоит отметить, что общей формулы для уравнений степени n \u0026gt;= 5 не существует.\n"});index.add({'id':3,'href':'/docs/misc/math/matrices/','title':"Матрицы",'content':"Матрицы Матрицами в математике называется прямоугольная таблица чисел:   $$ \\begin{pmatrix} a_11 \u0026 a_12 \u0026 ... \u0026 a_1m \\\\ a_21 \u0026 a_22 \u0026 ... * a_2m \\\\ ... \u0026 ... \u0026 ... \u0026 ... \\\\ a_n1 \u0026 a_n2 \u0026 ... \u0026 a_nm \\end{pmatrix} $$ Сами числа в этом случае называются элементами матрицы. Эту же матрицу для упрощения обозначают: $$ \\Vert a_{ij} \\Vert $$ Имея в виду, что i принимает значения от 1,\u0026hellip;,m, а j, соответственно, 1,\u0026hellip;,n. Если m = n, матрица называется квадратной, а число m=n ее порядком. Прямоугольная матрица, в которой n=1, называется столбцом. Квадратная матрица порядка 1 отождествляется с числом, поэтому понятие матрицы можно считать обобщением понятия числа.\n(0,1)-матрица - такая матрица, все элементы которой равны либо 0, либо 1. Наиболее известные подобные матрицы:\n O - нулевая матрица, то есть матрица, все элементы которой равны 0 E - единичная матрица, то есть квадратная матрица, в которой все \u0026ldquo;диагональные\u0026rdquo; элементы равны 1, а остальные - 0  Алгебра произвольных квадратных матриц Пусть $$ A = \\Vert a_{ij} \\Vert , B = \\Vert b_{ij} \\Vert $$ квадратные матрицы порядка n. Матрицы A и B считаются равными, если $$ a_{ij} = b_{ij} $$ для всех возможных i и j.\nСуммой A + B матриц A и B называется такая матрица C, элементы, которой равны сумме элементов исходных матриц, то есть матрицы складываются \u0026ldquo;поэлементно\u0026rdquo;.\n"});index.add({'id':4,'href':'/docs/','title':"Docs",'content':""});index.add({'id':5,'href':'/','title':"Introduction",'content':"Welcome to the Morggoth's wiki Here I'll post my notes and summaries.\n"});index.add({'id':6,'href':'/docs/misc/old_hardware/','title':"Old hardware",'content':"Old hardware notes Compaq Evo n600c Solaris 9 notes How to add on-board network interface in the system:\necho \u0026#39;iprb \u0026#34;pci8086,1038\u0026#34;\u0026#39; \u0026gt;\u0026gt; /etc/driver_aliases ifconfig iprb0 plumb # OR \u0026#34;touch /reconfigure; init 6\u0026#34;, but bit I didn\u0026#39;t check this method echo `hostname` \u0026gt; /etc/hostname.iprb0 sync reboot Source\nAnd configure this interface to using dhcp:\n Edit /etc/default/dhcpagent by root user ( previously need to add write permissions to this file ). Need to uncomment and modify entry:  RELEASE_ON_SIGTERM=yes Create appropriate interface file to enable dhcp:  touch /etc/dhcp.iprb0 Reboot the machine.  Source\n"});index.add({'id':7,'href':'/docs/languages/scala/','title':"Scala",'content':"Scala Переменные val x // константа def x // вычисляются каждый раз, когда на них ссылаются lazy val x // вычисляется не больше одного раза в момент первого к ней обращения var x // \u0026#34;настоящая\u0026#34; переменная, которая может быть переопределена Области видимости { val x = \u0026#34;Inner\u0026#34; println(x) } println(x) // Error!!1! Пространства имен Идентификаторы:  стабильные  package параметр функции val lazy val object   нестабильные:  def    Импортирование: import com.example.Module.{name1, name2} // нескольких сущностей из пакета import com.example.Module._ // все имена из пространства import com.example.Module.{name1 =\u0026gt; newName} // переименование при импорте import com.example.Module.{_, name1 =\u0026gt; _} // импортирование всех имен, кроме указанных Типы A \u0026lt;: B // Тип А является подтипом типа В, когда все значения А могут использоваться как значения типа В.  A \u0026lt;: Any // Надтип для любого другого типа  A \u0026lt;: AnyRef // Надтип для любых ссылочных типов A \u0026lt;: AnyVal // Надтип для любых примитивных типов  val x: String = \u0026#34;Some string\u0026#34; val y: AnyRef = x val z: Any = y val a: Int = 4 val b: AnyVal = a val c: Any = b Nothing \u0026lt;: // является подтипом любого типа, в основном используется при генерации ошибок Примитивные типы:  Целые числа (знаковые)  Byte (1 byte) Short (2 byte) Int (4 byte) Long (8 byte)   Дробные числа:  Float (4 byte) Double (8 byte)   Символы  Char (2 byte)   Булевые значения:  Boolean   Единичный тип:  Unit (значение этого типа константно, используется, например, для типа значения, возвращаемого из функции, если оно нас не интересует)    Числа val a = 3 // Int val b = -5L // Long val c = 10.0 // Double val d: Float // Явно указанный Float val e = 1.03e1 // Вариант записи с мантиссой (научная форма записи) Алгебраические операции с числами: val x = -5 val y = 3 x + y // Сложение x - y // Вычитание x * y // Умножение x / y // Целочисленное деление x % y // Взятие остатка -x // Унарный минус Побитовые операции с числами: val x = 0xF val y = 0XA1 x \u0026gt;\u0026gt; y // побитовый сдвиг вправо x \u0026lt;\u0026lt; y // -//- влево x | y // -//- ИЛИ x \u0026amp; y // -//- И x ^ y // -//- исключающее ИЛИ ~x // -//- инверсия Порядок операций (по возрастанию, определяется по первому символу оператора)  символы | ^ \u0026amp; = ! \u0026lt;\u0026gt; : + - * / % все остальные знаки  Ссылочные типы для больших чисел val x = BigInt(10) // Целочисленный тип, содержащий неограниченное количество цифр val y = BigDecimal(10) // Дробное число, так же не ограниченное по длине val z = BigInt(\u0026#34;1000\u0026#34;) // Эти типы могу быть инициализированы как числом, так и строчным представлением числа  x pow 100 // Операция возведения в степень для BigInt, не дающая переполнения x gcd y // Нахождение наибольшего общего делителя для двух больших чисел Булевые значения val a = true val b = false Операции сравнения: val a = 1 \u0026gt; 5 // Больше val b = 1 \u0026lt; 5 // Меньше val c = 1 \u0026lt;= 5 // Меньше или равно val d = 1 \u0026gt;= 5 // Больше или равно val e = 1 == 5 // Равно val f = 1 != 5 // Не равно Логические операции: val x = 1 \u0026gt; 5 val y = \u0026#34;Example\u0026#34; contains \u0026#34;a\u0026#34; x \u0026amp;\u0026amp; y // И x || y // ИЛИ !x // НЕ Равенство: Сравнивать объекты разных типов можно, но компилятор выдаст предупреждение.\nСравнение по ссылке:\nval x = \u0026#34;Te\u0026#34; val y = \u0026#34;st\u0026#34; val a = x + y val b = x + y a == b // true, так как значения одинаковые a eq b // false, так как ссылки разные В Java все константные строки интернированы: компилятор производит оптимизацию, в результате чего, одинаковые строковые литералы ссылаются на один и тот же объект в памяти. Поэтому:\nval s1 = \u0026#34;foo\u0026#34; val s2 = \u0026#34;foo\u0026#34; println(s1 eq s2) // true Строки val name = \u0026#34;Username\u0026#34; // Объявление строки val greet = \u0026#34;Hello\u0026#34; + name + \u0026#34;!!!\u0026#34; // Конкатенация val greet2 = s\u0026#34;Hello $name!!!\u0026#34; // Интерполяция val multiLine = \u0026#34;\u0026#34;\u0026#34; multi line string \u0026#34;\u0026#34;\u0026#34; Операции: val s = \u0026#34;aaabbb\u0026#34; s.startsWith(\u0026#34;aa\u0026#34;) s.endsWith(\u0026#34;bb\u0026#34;) s.contains(\u0026#34;ab\u0026#34;) s.matches(\u0026#34;a+b+\u0026#34;) // regexp Практически любой объект имеет метод toString:\nval x = 2 x.toString \u0026#34;x is \u0026#34; + x // При конкатенации приведение к строке происходит автоматически Методы Способ оформления переиспользуемого фрагмента кода.\ndef plusOne(number: Int): Int = number + 1 | | | | | | | | | | | +-- тело метода | | | | +-- возвращаемый тип | | | +-- тип параметра | | +-- имя параметра | +-- имя метода +-- ключевое слово // Вызов метода plusOne(4) // 5 Тип результата может быть опущен в случае, если он очевидно следует из тела метода. В этом случае тип будет выведен автоматически:\ndef plusOne(number: Int) = number + 1 Несколько параметров передаются через запятую:\ndef plusOne(x: Int, y: Int, z: Int): Int = x + y + z plusOne(1, 2, 3) // 6 У метода может быть несколько списков параметров. В этом случае при вызове метода входные параметры так же должны быть сгруппированы соответствующим образом:\ndef plusOne(x: Int, y: Int)(z: Int): Int = x + y + z plusOne(1, 2)(3) // 6 Так же у метода может не быть параметров, в этом случае, он воспринимается как \u0026ldquo;переменная\u0026rdquo;, значение которой вычисляется каждый раз при обращении (см. начало)\ndef sixty: Int = 10 * 6 sixty // 60 Тело метода может быть обернуто в фигурные скобки. Возвращено будет значение последнего выражения.\ndef plusAndPrint(x: Int, y: Int): Int = { val result = x + y println(s\u0026#34;$x+ $y= $result\u0026#34;) result } plusAndPrint(2, 4) // prints \u0026#34;2 + 4 = 6\u0026#34;, returns 6 Если метод не производит какие-либо действия, не возвращая ничего, то его возвращаемым типом будет Unit.\ndef plusAndPrint(x: Int, y: Int): Unit = { val result = x + y println(s\u0026#34;$x+ $y= $result\u0026#34;) } plusAndPrint(2, 4) // prints \u0026#34;2 + 4 = 6\u0026#34; Методы могут быть вызваны в телах других методов. В этом случае вложенный метод может ссылаться на параметры внешнего:\ndef plusMul(q: Int, x: Int, y: int): Int = { def mul(u: Int) = q * u mul(x) + mul(y) } plusMul(10, 2, 3) // 50 Последний параметр может быть объявлен повторяемым, то есть он может использоваться как коллекция:\ndef sumAllTimes(u: Int, nums: Int*): Int = u * nums.sum sumAllTimes(3, 1, 2, 3) // 3 * (1 + 2 + 3) = 18 Значение по умолчанию и именованные аргументы:\ndef plus3(x: Int, y: Int = 0, z: Int = 0): Int = 100 * x + 10 * y + z plus3(1) // 100 plus3(1, 2) // 120 plus3(1, 2, 3) // 123  plus3(x = 1) // 100 plus3(1, z = 2) // 102 plus3(x = 1, z = 3, y =2) // 123 При передаче параметра по имени его значение вычисляется не всегда а только тогда, когда в этом действительно есть необходимость. Но стоит отметить, что он будет вычислен столько раз, сколько раз на него будут ссылаться, что может привести к сложно отлаживаемым багам:\ndef replaceNegative(x: Int, z: =\u0026gt; Int): Int = if (x \u0026gt;= 0) x else z replaceNegative(1, 3 * 3 * 3) // 1 replaceNegative(-1, 3 * 3 * 3) // 27 Для рекурсивных функций указание типа обязательно\ndef sumRange(from: Int, to: Int): Int = { if ( to \u0026lt; from ) 0 else from + sumRange(from + 1, to) } sumRange(1, 10) // 55 Функции Функция - выражение, которое может быть использовано как метод.\nval x: Int =\u0026gt; Int = ... val y: (Int, Int) =\u0026gt; Int = ... // Максимальное количество параметров - 22 Лямбда-абстракция Значения функций можно задавать с помощью лямбда-синтаксиса\nval x: Int =\u0026gt; Int = x =\u0026gt; x + 1 val y: (Int, Int) =\u0026gt; Int = (x, y) =\u0026gt; x + y Тип параметров можно указывать прямо в лямбда-выражении, в этом случае компилятор попробует вывести тип самостоятельно\nval addOne = (x: Int) =\u0026gt; x + 1 val plus = (x: Int, y: Int) =\u0026gt; x + y Короткая запись может быть использована в случае, если каждый параметр используется только один раз и вызывается и все параметры вызываются в том же порядке, в котором передаются в функцию:\nval addOne: Int =\u0026gt; Int = _ + 1 val plus = (_: Int) + (_: Int) Эта-конверсия Еще один метод объявления функции, путем конвертации метода:\ndef addOnde(x: Int) = x + 1 val add1 = addOne _ def plus(x: Int, y: Int) = x + y val pl: (Int, Int) =\u0026gt; Int = plus // подчеркивание можно опустить, если для компилятора очевидно, что в этом месте ожидается функция "});index.add({'id':8,'href':'/docs/languages/c_sharp/','title':"C#",'content':"C# notes Hello world using System;\rpublic class Test\r{\rpublic static void Main()\r{\rConsole.WriteLine(\u0026#34;Hello World!\u0026#34;);\r}\r}\rVariables var varName = \u0026#34;var value\u0026#34;;\rString varName2 = \u0026#34;another string\u0026#34;;\rFlow control if (bool condition) {\r...\r} else {\r...\r}\r"});index.add({'id':9,'href':'/docs/misc/math/','title':"Книга для чтения по высшей математике",'content':"Книга для чтения по высшей математике Н.Л. Белая\nН.Н. Петров\nОгромное спасибо авторам за терпение, проявленное при обучении гуманитариев и за это прекрасное пособие.\n \u0026ldquo;Начала\u0026rdquo; Евклида Теория множеств Числа Комплексные числа Матрицы Аналитическая геометрия Нечёткие множества Теория пределов Производная Интеграл Дифференциальные уравнения Теория вероятностей Статистика Теория игр Теория графов  "});index.add({'id':10,'href':'/docs/languages/c/','title':"C",'content':"C notes Pointers int x = 1, y = 2, z[10]; int *ip; /* ip -\u0026gt; int*/ ip = \u0026amp;x; /* ip -\u0026gt; x */ y = *ip; /* y = 1 */ *ip = 0; /* x = 0 */ ip = \u0026amp;z[0]; /* ip -\u0026gt; z[0]*/ При передаче в функцию, переменные копируются, поэтому для изменения данных во внешней функции нужно передавать указатели.\nFile open modes    mode description starts\u0026hellip;     r/rb open for reading (The file must exist) beginning   w/wb open for writing (creates file if it doesn't exist). Deletes content and overwrites the file. beginning   a/ab open for appending (creates file if it doesn't exist) end   r+/rb+/r+b open for reading and writing (The file must exist) beginning   w+/wb+/w+b open for reading and writing. If file exists deletes content and overwrites the file, otherwise creates an empty new file beginning   a+/ab+/a+b open for reading and writing (append if file exists) end    "});index.add({'id':11,'href':'/docs/misc/chromeos/','title':"ChromeOS",'content':"Chrome OS Crew Crew is a Crome OS package manager.\nProblem like this:\nchronos@localhost ~/Downloads $ crew install neovim neovim: Neovim is a refactor, and sometimes redactor, in the tradition of Vim (which itself derives from Stevie). https://neovim.io/ version 0.2.0 Precompiled binary available, downloading... curl: error while loading shared libraries: libmetalink.so.3: cannot open shared object file: No such file or directory Traceback (most recent call last): 9: from /usr/local/bin/crew:974:in `\u0026lt;main\u0026gt;\u0026#39; 8: from /usr/local/bin/crew:905:in `install_command\u0026#39; 7: from /usr/local/bin/crew:905:in `each\u0026#39; 6: from /usr/local/bin/crew:909:in `block in install_command\u0026#39; 5: from /usr/local/bin/crew:611:in `resolve_dependencies_and_install\u0026#39; 4: from /usr/local/bin/crew:697:in `install\u0026#39; 3: from /usr/local/bin/crew:430:in `download\u0026#39; 2: from /usr/local/bin/crew:430:in `chdir\u0026#39; 1: from /usr/local/bin/crew:437:in `block in download\u0026#39; /usr/local/bin/crew:437:in `read\u0026#39;: No such file or directory @ rb_sysopen - ./neovim-0.2.0-chromeos-armv7l.tar.xz (Errno::ENOENT) resolvs by:\ncrew remove curl \u0026amp;\u0026amp; crew install curl "});index.add({'id':12,'href':'/docs/languages/java/','title':"Java",'content':"Java cheat sheets Type conversion a + b = result if a || b is double: result is double else if a || b is float: result is float else if a || b is long: result is long else: result is int Referencing subclass objects Let's define few example classes:\nclass SuperClass { ... } class SubClassOne extends SuperClass { ... } class SubClassTwo extends SuperClass { ... } There are two ways to refer to a subclass object:\n Subclass reference:  SubClassOne varOne = new SubClassOne(); SubClassTwo varTwo = new SubClassTwo();  Superclass reference:  SuperClass varOne = new SubClassOne(); SuperClass varTwo = new SubClassTwo();  We cannot assign an object of one subclass to the reference of another subclass because they don't inherit each other:  SubClassOne varOne = new SubClassTwo(); // Error!!1!  We cannot assign an object of the parent class to the reference of int subclass:  SubClassOne varOne = new SuperClass(); // Error!!1!   Polymorphism Polymorphism means that something (an object or another entity) has many forms.\nJava provides two types of polymorphism:\n static (compile-time; achieved by method overloading) dynamic (run-time; based on inheritance and method overriding)  Method overriding is when a subclass redefines a method of the superclass with the same name.\nThe run-time polymorphism relies on two principles:\n a reference variable of the superclass can refer to any subtype object; a superclass method can be overridden in a subclass.  "});index.add({'id':13,'href':'/docs/misc/macos/','title':"macOS",'content':"Terminal utils Mount (linux distro) ISO First we attach ISO to system:\nhdiutil attach -nomount /path/to/ISO returns something like this:\n/dev/disk2 Apple_partition_scheme /dev/disk2s1 Apple_partition_map /dev/disk2s2 Apple_HFS then mount need device to mountpoint:\nmount -t cd9660 /dev/disk2 /path/to/mount And after usage:\numount /dev/disk2 hdiutil detach disk2 "});index.add({'id':14,'href':'/docs/misc/mikrotik/','title':"Mikrotik",'content':"NetInstall Netinstall tool originaly delevoped for Windows. I don`t test it via wine.\r Disable Firewall Connect PC to Port 1 on Mikrotik Disable all other network interfaces on the PC - LAN, Wireless, Virtualbox Set static IP of 192.168.88.3 subnet mask 255.255.255.0 gateway 192.168.88.1 on PC Run NetInstall (download page) Select \u0026ldquo;Net Booting\u0026rdquo; Mark \u0026ldquo;Boot Serve Enabled\u0026rdquo; Selected Client IP address of 192.168.88.1 Keep reset pressed while powering on Keep holding the reset pin till a beep sounds. Release immediately Router showed up in Netinstall's list Unzipped \u0026ldquo;all_packages-mipsbe-X.X.zip\u0026rdquo; Selected need packages or all of them by browsing to the unzipped directory and using the \u0026ldquo;Select All\u0026rdquo; button Clicked on \u0026ldquo;Install\u0026rdquo; The progress bar moved to 100% as the packages were uploaded The router rebooted - Beep once, some time later (1 min or so if I recollect) a second beep    source oficial wiki  "});index.add({'id':15,'href':'/docs/misc/tips_and_tricks/','title':"Tips \u0026 Tricks",'content':"Common Generate password $ openssl rand -base64 14 $ gpg --gen-random --armor 1 14 $ cat /dev/urandom | tr -dc a-zA-Z0-9 | fold -w 14 | head -n 1 Generate missed pub key from private $ ssh-keygen -y -f ~/.ssh/id_rsa \u0026gt; ~/.ssh/id_rsa.pub Create a large file  Linux \u0026amp; all filesystems  xfs_mkfile 10240m 10Gigfile  Linux \u0026amp; and some filesystems (ext4, xfs, btrfs and ocfs2)  fallocate -l 10G 10Gigfile  OS X, Solaris, SunOS and probably other UNIXes  mkfile 10240m 10Gigfile Source\nMySQL Change user pass ALTER USER \u0026#39;user\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;NEW_USER_PASSWORD\u0026#39;; FLUSH PRIVILEGES; Granting User Connections From Remote Hosts: GRANT ALL PRIVILEGES ON *.* TO \u0026#39;user\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;my-new-password\u0026#39; WITH GRANT OPTION; Git Empty commit $ git commit --allow-empty -m \u0026#34;Empty commit message\u0026#34; Tmux :setw synchronize-panes "});index.add({'id':16,'href':'/docs/mooc/sams_cv/week1/','title':"Нейрон и нейронная сеть",'content':"Нейрон и нейронная сеть Строение биологического нейрона:  ядро (тело) нейрона дендриты (малые отростки; служат для приема сигнала от других нейронов) аксон (большой отросток; служит для передачи сигнала к другим нейронам) синапс (соединение аксона одного нейрона с дендритом другого нейрона; изменяется со временем, в зависимости от обстоятельств может становиться сильнее или слабее)  сильный (обеспечивает практически полную передачу электрического сигнала) слабый (практически не передает сигнал)    Тренировка биологической нейронной сети заключается в настройке синапса.\nНейрон накапливает заряд до определенного предела и только после этого сигнал уходит по аксону к дендритам других нейронов.\nМатематическая модель нейрона  сумматор вход выход функция активации (аналог механизма накопления заряда) синаптический вес (коэффициент входящего сигнала; настраиваемый параметр) смещение (настраиваемый параметр)    $$ y = f(z) = f(w_0x_0 + w_1x_1 + w_2x_2 + b) = f(\\lang w,x \\rang + b) $$ Где:\n y - выходное значение z - результат работы сумматора f(z) - функция активации w - синаптический вес x - входное значение b - смещение  \u0026lt;\u0026gt; - скалярное произведение\nФункция активации  Пороговая (аналогична существующей в биологическом нейроне)  $$ x = \\begin{cases} 0 \u0026\\text{if } x 0 \\end{cases} $$ Разделяющая поверхность - точка, в которой функция меняет значение с 0 на 1. В этой точке аргумент функции активации равен 0. Это плоскость, которая задается вектором w и смещением b. Положительное значение функции по отношению к разделяющей поверхности сонаправлено с вектором w.\nСигмоида  $$ \\sigma(x) = \\dfrac{1}{e^{-x}} \\\\ \\sigma(x) \\rarr 1 \\text{ if } x \\rarr \\infin \\\\ \\sigma(x) \\rarr 0 \\text{ if } x \\rarr -\\infin \\\\ $$ Если ввести параметр температуры (Т), появляется возможность регулировать наклон сигмоиды. При низких значениях температуры график сигмоиды стремится к графику пороговой функции.\n$$ \\sigma(x) = \\dfrac{1}{e^{\\frac{-x}{T}}} $$ Нейронные сети При объединении нейронов между собой разделяющая поверхность перестаёт быть линейной и может, в том числе, образовывать несвязанные друг с другом области.\nКомбинировать полносвязанные линейные нейроны бессмысленно.\nДоп материалы  Нейроны не любят одиночество Рост отростков одного нейрона Биологический нейрон (учебный фильм СССР) Частная жизнь нейрона 1987 (учебный фильм СССР) Нейроны мозга (Discovery) Science - Structure of Neuron_New Inside the Brain: Unraveling the Mystery of Alzheimer's Disease [HQ] Transport inside the brain: The basic mechanisms of neuronal trafficking  "});index.add({'id':17,'href':'/docs/mooc/sams_cv/','title':"Нейронные сети и компьютерное зрение",'content':"Конспект курса Нейронные сети и компьютерное зрение\n"});index.add({'id':18,'href':'/docs/mooc/sams_cv/week2/','title':"Строим первую нейронную сеть",'content':"Строим первую нейронную сеть Восстановление зависимостей Размеченная обучающая выборка состоит из объектов, для которых мы знаем:\n некоторые признаки метку объекта  Хорошей практикой является разделение датасета на три поддатасета:\n train (используется непосредственно для обучения модели) valid (используется для подстраивания параметров обучения нашей модели) test (используется для проверки окончательного результата)  Компоненты нейронной сети  Архитектура нейронной сети Функции потерь (способ определения результата работы создаваемой сети; минимум этой функции соответствует оптимально настроенной сети) Метод оптимизации (говорит о том, как именно нужно изменить настройки сети для минимизации функции потерь) Метрики (показывают насколько успешно сеть решает поставленную задачу; например: точность; в отличии от функции потерь могут быть не дифференцируемыми)  Результирующая зависимость - сумма сигмоидных функций с соответствующими параметрами.\nФункция потерь Для задач восстановления скрытых зависимостей зачастую в качестве функции потерь используют функцию среднего квадрата ошибки (MSE, mean squared error):\nMSE=(1/N)*sum_N_i=1(y_av_i - y_i)^2 где:\n y_av_i - результат работы сети y_i - целевые значения  То есть это сумма квадратов отклонения полученных результатов от ожидаемых значений.\nАлгоритмы настройки нейронной сети Градиентный спуск w0 - вектор весов, который содержит все значения весов и смещений, которые используются в сети.\nГрадиент функции потерь - вектор, состоящий из производных по каждой из координат функции. Градиент указывает в сторону наибольшего роста функции потерь =\u0026gt; требуется сделать шаг из точки w0 в направлении обратном направлению градиента. Далее шаги повторяются.\nГрадиентный спуск находит минимум функции, но не гарантирует нахождения оптимального минимума.\nОграничения, накладываемые на функцию потерь:\n должна быть дифференцируемой (если в некотором множестве точек производная не определена, ее можно доопределить) производная функции потерь не должна быть равна нулю в большинстве точек  Правило цепочки (правило производной сложной функции) Граф вычисления - порядок вычисления сложной функции.\nпересмотреть\n"});index.add({'id':19,'href':'/categories/','title':"Categories",'content':""});index.add({'id':20,'href':'/docs/mooc/','title':"MOOC",'content':"Different MOOC nones "});index.add({'id':21,'href':'/tags/','title':"Tags",'content':""});})();